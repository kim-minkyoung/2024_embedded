###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.1.15669/W32 for ARM       22/Dec/2024  19:06:49
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  C:\Users\pnu3\Desktop\project_test (1) 2-1\user\main.c
#    Command line =  
#        -f C:\Users\pnu3\AppData\Local\Temp\EWDF62.tmp
#        ("C:\Users\pnu3\Desktop\project_test (1) 2-1\user\main.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F10X_CL -lC
#        "C:\Users\pnu3\Desktop\project_test (1) 2-1\Debug\List" -o
#        "C:\Users\pnu3\Desktop\project_test (1) 2-1\Debug\Obj" --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M3 -e --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        "C:\Users\pnu3\Desktop\project_test (1)
#        2-1\libraries\CMSIS\DeviceSupport\" -I
#        "C:\Users\pnu3\Desktop\project_test (1)
#        2-1\libraries\CMSIS\DeviceSupport\Startup\" -I
#        "C:\Users\pnu3\Desktop\project_test (1)
#        2-1\libraries\STM32F10x_StdPeriph_Driver_v3.5\inc\" -I
#        "C:\Users\pnu3\Desktop\project_test (1)
#        2-1\libraries\STM32F10x_StdPeriph_Driver_v3.5\src\" -I
#        "C:\Users\pnu3\Desktop\project_test (1) 2-1\user\" -I
#        "C:\Users\pnu3\Desktop\project_test (1) 2-1\user\inc\" -I
#        "C:\Users\pnu3\Desktop\project_test (1) 2-1\libraries\LCD\" -Ol -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =  
#        C:\Users\pnu3\Desktop\project_test (1) 2-1\Debug\List\main.lst
#    Object file  =  
#        C:\Users\pnu3\Desktop\project_test (1) 2-1\Debug\Obj\main.o
#
###############################################################################

C:\Users\pnu3\Desktop\project_test (1) 2-1\user\main.c
      1          #include "stm32f10x.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void __NVIC_EnableIRQ(IRQn_Type)
   \                     __NVIC_EnableIRQ: (+1)
   \   00000000   0x0001             MOVS     R1,R0
   \   00000002   0xB249             SXTB     R1,R1            ;; SignExt  R1,R1,#+24,#+24
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD409             BMI.N    ??__NVIC_EnableIRQ_0
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF010 0x011F      ANDS     R1,R0,#0x1F
   \   0000000E   0x408A             LSLS     R2,R2,R1
   \   00000010   0x.... 0x....      LDR.W    R1,??DataTable17  ;; 0xe000e100
   \   00000014   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000016   0x0940             LSRS     R0,R0,#+5
   \   00000018   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
   \                     ??__NVIC_EnableIRQ_0: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
      2          #include "core_cm3.h"
      3          #include "misc.h"
      4          #include "stm32f10x_gpio.h"
      5          #include "stm32f10x_rcc.h"
      6          #include "stm32f10x_usart.h"
      7          #include "stm32f10x_adc.h"
      8          #include "stm32f10x_tim.h"
      9          #include "stm32f10x_HC-SR04.h"
     10          #include "stm32f10x_exti.h"
     11          #include "time.h"
     12          
     13          // UART @@@

   \                                 In section .bss, align 1
     14          char flagUART1 = 0;   // USART1@@ @@@ @@ @ @@@@ @@@
   \                     flagUART1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     15          char flagUART2 = 0;   // USART2@@ @@@ @@ @ @@@@ @@@
   \                     flagUART2:
   \   00000000                      DS8 1
     16          

   \                                 In section .bss, align 1
     17          char wordFromUART1;   // USART1@@ @@ @@@ @@ @@
   \                     wordFromUART1:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
     18          char wordFromUART2;   // USART2@@ @@ @@@ @@ @@
   \                     wordFromUART2:
   \   00000000                      DS8 1
     19          
     20          // @@ @@ @@ @@

   \                                 In section .bss, align 8
     21          volatile double pressureValue = 0; // @@ @@  @
   \                     pressureValue:
   \   00000000                      DS8 8

   \                                 In section .bss, align 4
     22          int flag = 0;             // @@ @@ @@@
   \                     flag:
   \   00000000                      DS8 4

   \                                 In section .data, align 8
     23          double pressureThreshold1 = 500; // @@ @@@ 1 - @@@@ @@ @@
   \                     pressureThreshold1:
   \   00000000   0x00000000         DC32 0H, 407F4000H
   \              0x407F4000   

   \                                 In section .data, align 8
     24          double pressureThreshold2 = 1000; // @@ @@@ 2
   \                     pressureThreshold2:
   \   00000000   0x00000000         DC32 0H, 408F4000H
   \              0x408F4000   

   \                                 In section .bss, align 8
     25          double dist = 0;          // @@ @@@
   \                     dist:
   \   00000000                      DS8 8
     26          
     27          
     28          // @@ @@@@@ @@
     29          void RCC_Configure(void);      // @@ @@
     30          void GPIO_Configure(void);     // GPIO @@  
     31          void USART1_Init(void);        // USART1 @@@
     32          void USART2_Init(void);        // USART2 @@@
     33          void sendDataUART1(uint16_t data); // USART1@@ @@@ @@
     34          void sendDataUART2(uint16_t data); // USART2@@ @@@ @@
     35          void NVIC_Configure(void);     // @@@@ @@
     36          void ADC_Configure(void);      // ADC @@
     37          void ADC1_2_IRQHandler(void);  // ADC @@@@ @@@
     38          void USART1_IRQHandler(void);  // USART1 @@@@ @@@
     39          void USART2_IRQHandler(void);  // USART2 @@@@ @@@
     40          void InitHCSR04(void);         // @@@ @@ @@@
     41          void setRGBLED(int flag);      // RGB LED @@
     42          void TIM4_Configure(void);     // TIM4 @@@ @@
     43          void moveMotor(uint16_t var); // @@ @@ @@
     44          
     45          void open(void);  // @ @@ @@
     46          void close(void); // @ @@ @@
     47          
     48          // @@ @@ @@

   \                                 In section .text, align 2, keep-with-next
     49          void RCC_Configure(void) {
   \                     RCC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     50              // GPIO @@ @@ @@@
     51              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // Port A @@@
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x2004             MOVS     R0,#+4
   \   00000006   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     52              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // Port B @@@  
   \   0000000A   0x2101             MOVS     R1,#+1
   \   0000000C   0x2008             MOVS     R0,#+8
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     53              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // Port C @@@
   \   00000012   0x2101             MOVS     R1,#+1
   \   00000014   0x2010             MOVS     R0,#+16
   \   00000016   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     54              RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); // Port D @@@
   \   0000001A   0x2101             MOVS     R1,#+1
   \   0000001C   0x2020             MOVS     R0,#+32
   \   0000001E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     55              
     56              // ADC @@ @@@
     57              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   \   00000022   0x2101             MOVS     R1,#+1
   \   00000024   0xF44F 0x7000      MOV      R0,#+512
   \   00000028   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     58              RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC2, ENABLE);
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0xF44F 0x6080      MOV      R0,#+1024
   \   00000032   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     59              
     60              // USART @@ @@@
     61              RCC_APB2PeriphClockCmd(RCC_APB2ENR_USART1EN, ENABLE); // USART1
   \   00000036   0x2101             MOVS     R1,#+1
   \   00000038   0xF44F 0x4080      MOV      R0,#+16384
   \   0000003C   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     62              RCC_APB1PeriphClockCmd(RCC_APB1ENR_USART2EN, ENABLE); // USART2
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0xF45F 0x3000      MOVS     R0,#+131072
   \   00000046   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     63              
     64              // AFIO @@ @@@ 
     65              RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   \   0000004A   0x2101             MOVS     R1,#+1
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0x.... 0x....      BL       RCC_APB2PeriphClockCmd
     66              
     67              // @@@@ TIM3 @@@
     68              RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);  // Timer4 enable
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0x.... 0x....      BL       RCC_APB1PeriphClockCmd
     69          } 
   \   0000005A   0xBD01             POP      {R0,PC}          ;; return
     70          
     71          // GPIO @@ @@

   \                                 In section .text, align 2, keep-with-next
     72          void GPIO_Configure(void) {
   \                     GPIO_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
     73              GPIO_InitTypeDef GPIO_InitStructure;
     74              
     75              // @@ @@ 1 (PC0, ADC @@ 10)
     76              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     77              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0xF88D 0x0002      STRB     R0,[SP, #+2]
     78              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF88D 0x0003      STRB     R0,[SP, #+3]
     79              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   00000014   0x4669             MOV      R1,SP
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40011000
   \   0000001A   0x.... 0x....      BL       GPIO_Init
     80          
     81              // @@@@ @@ (@@@ @)
     82              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
   \   0000001E   0xF44F 0x5080      MOV      R0,#+4096
   \   00000022   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     83              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000026   0x2003             MOVS     R0,#+3
   \   00000028   0xF88D 0x0002      STRB     R0,[SP, #+2]
     84              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
   \   0000002C   0x2028             MOVS     R0,#+40
   \   0000002E   0xF88D 0x0003      STRB     R0,[SP, #+3]
     85              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   00000032   0x4669             MOV      R1,SP
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40011400
   \   00000038   0x.... 0x....      BL       GPIO_Init
     86              
     87              // USART1 TX(PA9)
     88              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
   \   0000003C   0xF44F 0x7000      MOV      R0,#+512
   \   00000040   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     89              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000044   0x2003             MOVS     R0,#+3
   \   00000046   0xF88D 0x0002      STRB     R0,[SP, #+2]
     90              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000004A   0x2018             MOVS     R0,#+24
   \   0000004C   0xF88D 0x0003      STRB     R0,[SP, #+3]
     91              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000050   0x4669             MOV      R1,SP
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40010800
   \   00000056   0x.... 0x....      BL       GPIO_Init
     92              
     93              // USART1 TX(PA10)
     94              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
   \   0000005A   0xF44F 0x6080      MOV      R0,#+1024
   \   0000005E   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     95              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000062   0x2048             MOVS     R0,#+72
   \   00000064   0xF88D 0x0003      STRB     R0,[SP, #+3]
     96              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000068   0x4669             MOV      R1,SP
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40010800
   \   0000006E   0x.... 0x....      BL       GPIO_Init
     97          
     98              // USART2 TX(PA2)
     99              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \   00000072   0x2004             MOVS     R0,#+4
   \   00000074   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    100              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000078   0x2003             MOVS     R0,#+3
   \   0000007A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    101              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   0000007E   0x2018             MOVS     R0,#+24
   \   00000080   0xF88D 0x0003      STRB     R0,[SP, #+3]
    102              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   00000084   0x4669             MOV      R1,SP
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40010800
   \   0000008A   0x.... 0x....      BL       GPIO_Init
    103              
    104              // USART2 RX(PA3)
    105              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
   \   0000008E   0x2008             MOVS     R0,#+8
   \   00000090   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    106              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
   \   00000094   0x2048             MOVS     R0,#+72
   \   00000096   0xF88D 0x0003      STRB     R0,[SP, #+3]
    107              GPIO_Init(GPIOA, &GPIO_InitStructure);
   \   0000009A   0x4669             MOV      R1,SP
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable17_3  ;; 0x40010800
   \   000000A0   0x.... 0x....      BL       GPIO_Init
    108          
    109              // RGB LED @ @@ (GPIOB)
    110              // @@@ (PD2)
    111              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \   000000A4   0x2004             MOVS     R0,#+4
   \   000000A6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    112              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000AA   0x2003             MOVS     R0,#+3
   \   000000AC   0xF88D 0x0002      STRB     R0,[SP, #+2]
    113              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   000000B0   0x2010             MOVS     R0,#+16
   \   000000B2   0xF88D 0x0003      STRB     R0,[SP, #+3]
    114              GPIO_Init(GPIOD, &GPIO_InitStructure);
   \   000000B6   0x4669             MOV      R1,SP
   \   000000B8   0x.... 0x....      LDR.W    R0,??DataTable17_2  ;; 0x40011400
   \   000000BC   0x.... 0x....      BL       GPIO_Init
    115          
    116              // @@@ (PB2)
    117              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
   \   000000C0   0x2004             MOVS     R0,#+4
   \   000000C2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    118              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000C6   0x2003             MOVS     R0,#+3
   \   000000C8   0xF88D 0x0002      STRB     R0,[SP, #+2]
    119              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   000000CC   0x2010             MOVS     R0,#+16
   \   000000CE   0xF88D 0x0003      STRB     R0,[SP, #+3]
    120              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   000000D2   0x4669             MOV      R1,SP
   \   000000D4   0x.... 0x....      LDR.W    R0,??DataTable17_4  ;; 0x40010c00
   \   000000D8   0x.... 0x....      BL       GPIO_Init
    121          
    122              // @@@ (PC5)
    123              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
   \   000000DC   0x2020             MOVS     R0,#+32
   \   000000DE   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    124              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   000000E2   0x2003             MOVS     R0,#+3
   \   000000E4   0xF88D 0x0002      STRB     R0,[SP, #+2]
    125              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
   \   000000E8   0x2010             MOVS     R0,#+16
   \   000000EA   0xF88D 0x0003      STRB     R0,[SP, #+3]
    126              GPIO_Init(GPIOC, &GPIO_InitStructure);
   \   000000EE   0x4669             MOV      R1,SP
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable17_1  ;; 0x40011000
   \   000000F4   0x.... 0x....      BL       GPIO_Init
    127              
    128              // @@@@
    129              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
   \   000000F8   0xF44F 0x7080      MOV      R0,#+256
   \   000000FC   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    130              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   \   00000100   0x2003             MOVS     R0,#+3
   \   00000102   0xF88D 0x0002      STRB     R0,[SP, #+2]
    131              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
   \   00000106   0x2018             MOVS     R0,#+24
   \   00000108   0xF88D 0x0003      STRB     R0,[SP, #+3]
    132              GPIO_Init(GPIOB, &GPIO_InitStructure);
   \   0000010C   0x4669             MOV      R1,SP
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable17_4  ;; 0x40010c00
   \   00000112   0x.... 0x....      BL       GPIO_Init
    133          }
   \   00000116   0xBD01             POP      {R0,PC}          ;; return
    134          
    135          // USART1 @@@ @@

   \                                 In section .text, align 2, keep-with-next
    136          void USART1_Init(void)
    137          {
   \                     USART1_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    138              USART_InitTypeDef USART1_InitStructure;
    139          
    140              // Enable the USART1 peripheral
    141              USART_Cmd(USART1, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40013800
   \   00000008   0x.... 0x....      BL       USART_Cmd
    142          
    143              // TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    144              USART1_InitStructure.USART_BaudRate = 9600;
   \   0000000C   0xF44F 0x5016      MOV      R0,#+9600
   \   00000010   0x9000             STR      R0,[SP, #+0]
    145              USART1_InitStructure.USART_WordLength = (uint16_t) USART_WordLength_8b;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    146              USART1_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000018   0x200C             MOVS     R0,#+12
   \   0000001A   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    147              USART1_InitStructure.USART_Parity = (uint16_t) USART_Parity_No;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    148              USART1_InitStructure.USART_StopBits = (uint16_t) USART_StopBits_1;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    149              USART1_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    150          
    151              USART_Init(USART1, &USART1_InitStructure);
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40013800
   \   00000036   0x.... 0x....      BL       USART_Init
    152              // TODO: Enable the USART1 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    153              USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40013800
   \   00000044   0x.... 0x....      BL       USART_ITConfig
    154          
    155          }
   \   00000048   0xB005             ADD      SP,SP,#+20
   \   0000004A   0xBD00             POP      {PC}             ;; return
    156          
    157          // USART2 @@@ @@

   \                                 In section .text, align 2, keep-with-next
    158          void USART2_Init(void)
    159          {
   \                     USART2_Init: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    160              USART_InitTypeDef USART2_InitStructure;
    161          
    162              // Enable the USART2 peripheral
    163              USART_Cmd(USART2, ENABLE);
   \   00000002   0x2101             MOVS     R1,#+1
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x40004400
   \   00000008   0x.... 0x....      BL       USART_Cmd
    164          
    165              // TODO: Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    166              // Initialize the USART using the structure 'USART_InitTypeDef' and the function 'USART_Init'
    167              USART2_InitStructure.USART_BaudRate = 9600;
   \   0000000C   0xF44F 0x5016      MOV      R0,#+9600
   \   00000010   0x9000             STR      R0,[SP, #+0]
    168              USART2_InitStructure.USART_WordLength = (uint16_t)USART_WordLength_8b;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    169              USART2_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000018   0x200C             MOVS     R0,#+12
   \   0000001A   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    170              USART2_InitStructure.USART_Parity = (uint16_t)USART_Parity_No;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    171              USART2_InitStructure.USART_StopBits = (uint16_t)USART_StopBits_1;
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    172              USART2_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    173          
    174              USART_Init(USART2, &USART2_InitStructure);
   \   00000030   0x4669             MOV      R1,SP
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x40004400
   \   00000036   0x.... 0x....      BL       USART_Init
    175              // TODO: Enable the USART2 RX interrupts using the function 'USART_ITConfig' and the argument value 'Receive Data register not empty interrupt'
    176              USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
   \   0000003A   0x2201             MOVS     R2,#+1
   \   0000003C   0xF240 0x5125      MOVW     R1,#+1317
   \   00000040   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x40004400
   \   00000044   0x.... 0x....      BL       USART_ITConfig
    177          }
   \   00000048   0xB005             ADD      SP,SP,#+20
   \   0000004A   0xBD00             POP      {PC}             ;; return
    178          
    179          // USART1 @@@@ @@@

   \                                 In section .text, align 2, keep-with-next
    180          void USART1_IRQHandler() {
   \                     USART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    181          
    182              if(USART_GetITStatus(USART1,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40013800
   \   0000000A   0x.... 0x....      BL       USART_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD010             BEQ.N    ??USART1_IRQHandler_0
    183                  flagUART1 = 1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    184                  // the most recent received data by the USART1 peripheral
    185                  wordFromUART1 = USART_ReceiveData(USART1);
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40013800
   \   0000001E   0x.... 0x....      BL       USART_ReceiveData
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_8
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    186                  // clear 'Read data register not empty' flag
    187                  USART_ClearITPendingBit(USART1,USART_IT_RXNE);
   \   00000028   0xF240 0x5125      MOVW     R1,#+1317
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40013800
   \   00000030   0x.... 0x....      BL       USART_ClearITPendingBit
    188              }
    189          }
   \                     ??USART1_IRQHandler_0: (+1)
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    190          
    191          // USART2 @@@@ @@@

   \                                 In section .text, align 2, keep-with-next
    192          void USART2_IRQHandler() {
   \                     USART2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    193          
    194              if(USART_GetITStatus(USART2,USART_IT_RXNE)!=RESET){
   \   00000002   0xF240 0x5125      MOVW     R1,#+1317
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x40004400
   \   0000000A   0x.... 0x....      BL       USART_GetITStatus
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD010             BEQ.N    ??USART2_IRQHandler_0
    195                  flagUART2 = 1;
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17_9
   \   00000018   0x7008             STRB     R0,[R1, #+0]
    196                  // the most recent received data by the USART1 peripheral
    197                  wordFromUART2 = USART_ReceiveData(USART2);
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x40004400
   \   0000001E   0x.... 0x....      BL       USART_ReceiveData
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   00000026   0x7008             STRB     R0,[R1, #+0]
    198                  // clear 'Read data register not empty' flag
    199                  USART_ClearITPendingBit(USART2,USART_IT_RXNE);
   \   00000028   0xF240 0x5125      MOVW     R1,#+1317
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x40004400
   \   00000030   0x.... 0x....      BL       USART_ClearITPendingBit
    200              }
    201          }
   \                     ??USART2_IRQHandler_0: (+1)
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    202          

   \                                 In section .text, align 2, keep-with-next
    203          void sendDataUART1(uint16_t data) {
   \                     sendDataUART1: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    204              USART_SendData(USART1, data);
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17_5  ;; 0x40013800
   \   0000000A   0x.... 0x....      BL       USART_SendData
    205          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    206          

   \                                 In section .text, align 2, keep-with-next
    207          void sendDataUART2(uint16_t data) {
   \                     sendDataUART2: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x0001             MOVS     R1,R0
    208              USART_SendData(USART2, data);
   \   00000004   0xB289             UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable17_6  ;; 0x40004400
   \   0000000A   0x.... 0x....      BL       USART_SendData
    209          }
   \   0000000E   0xBD01             POP      {R0,PC}          ;; return
    210          
    211          // @@@@ @@@@ @@: TIM4 > USART > ADC

   \                                 In section .text, align 2, keep-with-next
    212          void NVIC_Configure(void) {
   \                     NVIC_Configure: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    213              NVIC_InitTypeDef NVIC_InitStructure;
    214          
    215              // NVIC Priority Group @@
    216              NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
   \   00000002   0xF44F 0x60A0      MOV      R0,#+1280
   \   00000006   0x.... 0x....      BL       NVIC_PriorityGroupConfig
    217                  
    218              // ADC1 @@@@
    219              NVIC_EnableIRQ(ADC1_2_IRQn);                  // ADC1_2 @@@@ @@@
   \   0000000A   0x2012             MOVS     R0,#+18
   \   0000000C   0x.... 0x....      BL       __NVIC_EnableIRQ
    220              NVIC_InitStructure.NVIC_IRQChannel = ADC1_2_IRQn;
   \   00000010   0x2012             MOVS     R0,#+18
   \   00000012   0xF88D 0x0000      STRB     R0,[SP, #+0]
    221              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x03;
   \   00000016   0x2003             MOVS     R0,#+3
   \   00000018   0xF88D 0x0001      STRB     R0,[SP, #+1]
    222              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xF88D 0x0002      STRB     R0,[SP, #+2]
    223              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xF88D 0x0003      STRB     R0,[SP, #+3]
    224              NVIC_Init(&NVIC_InitStructure);
   \   00000028   0x4668             MOV      R0,SP
   \   0000002A   0x.... 0x....      BL       NVIC_Init
    225          
    226              // USART1 @@@@
    227              NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
   \   0000002E   0x2025             MOVS     R0,#+37
   \   00000030   0xF88D 0x0000      STRB     R0,[SP, #+0]
    228              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xF88D 0x0001      STRB     R0,[SP, #+1]
    229              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0xF88D 0x0002      STRB     R0,[SP, #+2]
    230              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xF88D 0x0003      STRB     R0,[SP, #+3]
    231              NVIC_Init(&NVIC_InitStructure);
   \   00000046   0x4668             MOV      R0,SP
   \   00000048   0x.... 0x....      BL       NVIC_Init
    232          
    233              // USART2 @@@@
    234              NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
   \   0000004C   0x2026             MOVS     R0,#+38
   \   0000004E   0xF88D 0x0000      STRB     R0,[SP, #+0]
    235              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x01;
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xF88D 0x0001      STRB     R0,[SP, #+1]
    236              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0xF88D 0x0002      STRB     R0,[SP, #+2]
    237              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xF88D 0x0003      STRB     R0,[SP, #+3]
    238              NVIC_Init(&NVIC_InitStructure);
   \   00000064   0x4668             MOV      R0,SP
   \   00000066   0x.... 0x....      BL       NVIC_Init
    239              
    240              // TIM4 @@@@
    241              NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
   \   0000006A   0x201E             MOVS     R0,#+30
   \   0000006C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    242              NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x02;
   \   00000070   0x2002             MOVS     R0,#+2
   \   00000072   0xF88D 0x0001      STRB     R0,[SP, #+1]
    243              NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x00;
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0xF88D 0x0002      STRB     R0,[SP, #+2]
    244              NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
   \   0000007C   0x2001             MOVS     R0,#+1
   \   0000007E   0xF88D 0x0003      STRB     R0,[SP, #+3]
    245              NVIC_Init(&NVIC_InitStructure);
   \   00000082   0x4668             MOV      R0,SP
   \   00000084   0x.... 0x....      BL       NVIC_Init
    246          
    247          }
   \   00000088   0xBD01             POP      {R0,PC}          ;; return
    248          
    249          // ADC @@ @@

   \                                 In section .text, align 2, keep-with-next
    250          void ADC_Configure(void) {
   \                     ADC_Configure: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    251              ADC_DeInit(ADC1);
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   00000008   0x.... 0x....      BL       ADC_DeInit
    252              ADC_InitTypeDef ADC_InitStructure;
    253              
    254              ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x9000             STR      R0,[SP, #+0]
    255              ADC_InitStructure.ADC_ScanConvMode = ENABLE;
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0xF88D 0x0004      STRB     R0,[SP, #+4]
    256              ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xF88D 0x0005      STRB     R0,[SP, #+5]
    257              ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   \   0000001C   0xF45F 0x2060      MOVS     R0,#+917504
   \   00000020   0x9002             STR      R0,[SP, #+8]
    258              ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x9003             STR      R0,[SP, #+12]
    259              ADC_InitStructure.ADC_NbrOfChannel = 1;
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0xF88D 0x0010      STRB     R0,[SP, #+16]
    260              ADC_Init(ADC1, &ADC_InitStructure);
   \   0000002C   0x4669             MOV      R1,SP
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   00000032   0x.... 0x....      BL       ADC_Init
    261              
    262              // @@@@ 1,2 @@ @@
    263              ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_239Cycles5);
   \   00000036   0x2307             MOVS     R3,#+7
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x210A             MOVS     R1,#+10
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   00000040   0x.... 0x....      BL       ADC_RegularChannelConfig
    264              //ADC_RegularChannelConfig(ADC1, ADC_Channel_11, 2, ADC_SampleTime_239Cycles5);
    265              
    266              ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
   \   00000044   0x2201             MOVS     R2,#+1
   \   00000046   0xF44F 0x7108      MOV      R1,#+544
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   0000004E   0x.... 0x....      BL       ADC_ITConfig
    267              ADC_Cmd(ADC1, ENABLE);
   \   00000052   0x2101             MOVS     R1,#+1
   \   00000054   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   00000058   0x.... 0x....      BL       ADC_Cmd
    268              
    269              // ADC @@
    270              ADC_ResetCalibration(ADC1);
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   00000060   0x.... 0x....      BL       ADC_ResetCalibration
    271              while(ADC_GetResetCalibrationStatus(ADC1));
   \                     ??ADC_Configure_0: (+1)
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   00000068   0x.... 0x....      BL       ADC_GetResetCalibrationStatus
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD1F9             BNE.N    ??ADC_Configure_0
    272              
    273              ADC_StartCalibration(ADC1);
   \   00000070   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   00000074   0x.... 0x....      BL       ADC_StartCalibration
    274              while(ADC_GetCalibrationStatus(ADC1));
   \                     ??ADC_Configure_1: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   0000007C   0x.... 0x....      BL       ADC_GetCalibrationStatus
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD1F9             BNE.N    ??ADC_Configure_1
    275              
    276              ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x.... 0x....      LDR.W    R0,??DataTable17_11  ;; 0x40012400
   \   0000008A   0x.... 0x....      BL       ADC_SoftwareStartConvCmd
    277          }
   \   0000008E   0xB005             ADD      SP,SP,#+20
   \   00000090   0xBD00             POP      {PC}             ;; return
    278          
    279          // ADC @@ @@ @@@@ @@@

   \                                 In section .text, align 2, keep-with-next
    280          void ADC1_2_IRQHandler(void) {
   \                     ADC1_2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    281              if (ADC_GetITStatus(ADC1, ADC_IT_EOC) != RESET) {
   \   00000002   0xF44F 0x7108      MOV      R1,#+544
   \   00000006   0x....             LDR.N    R0,??DataTable17_11  ;; 0x40012400
   \   00000008   0x.... 0x....      BL       ADC_GetITStatus
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD00C             BEQ.N    ??ADC1_2_IRQHandler_0
    282                  // ADC @@ @ @@
    283                  pressureValue = ADC_GetConversionValue(ADC1);
   \   00000010   0x....             LDR.N    R0,??DataTable17_11  ;; 0x40012400
   \   00000012   0x.... 0x....      BL       ADC_GetConversionValue
   \   00000016   0x.... 0x....      BL       __aeabi_ui2d
   \   0000001A   0x....             LDR.N    R2,??DataTable17_12
   \   0000001C   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    284          
    285                  // @@@@ @@@ @@@
    286                  ADC_ClearITPendingBit(ADC1, ADC_IT_EOC);
   \   00000020   0xF44F 0x7108      MOV      R1,#+544
   \   00000024   0x....             LDR.N    R0,??DataTable17_11  ;; 0x40012400
   \   00000026   0x.... 0x....      BL       ADC_ClearITPendingBit
    287              }
    288          }
   \                     ??ADC1_2_IRQHandler_0: (+1)
   \   0000002A   0xBD01             POP      {R0,PC}          ;; return
    289          
    290          // TIM4 @@@ @@@ @@ (PWM @@)

   \                                 In section .text, align 2, keep-with-next
    291          void TIM4_Configure(void)
    292          {
   \                     TIM4_Configure: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    293              TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    294              TIM_OCInitTypeDef TIM_OCInitStructure;
    295              uint16_t prescale = (uint16_t) (SystemCoreClock / 1000000); // 72 * 10^6 / 10^6
   \   00000004   0x....             LDR.N    R0,??DataTable17_13
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable17_14  ;; 0xf4240
   \   0000000A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
    296              
    297              TIM_TimeBaseStructure.TIM_Period = 20000;                   // 72 * 10^6 / 72 / 20000 = 50 Hz
   \   0000000E   0xF644 0x6120      MOVW     R1,#+20000
   \   00000012   0xF8AD 0x1004      STRH     R1,[SP, #+4]
    298              TIM_TimeBaseStructure.TIM_Prescaler = prescale;
   \   00000016   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    299              TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    300              TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Down;
   \   00000020   0x2010             MOVS     R0,#+16
   \   00000022   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    301              
    302              TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   \   00000026   0x2060             MOVS     R0,#+96
   \   00000028   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    303              TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF8AD 0x0014      STRH     R0,[SP, #+20]
    304              TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    305              TIM_OCInitStructure.TIM_Pulse = 1500;   // us
   \   00000038   0xF240 0x50DC      MOVW     R0,#+1500
   \   0000003C   0xF8AD 0x0012      STRH     R0,[SP, #+18]
    306              TIM_OC3Init(TIM4, &TIM_OCInitStructure);
   \   00000040   0xA903             ADD      R1,SP,#+12
   \   00000042   0x....             LDR.N    R0,??DataTable17_15  ;; 0x40000800
   \   00000044   0x.... 0x....      BL       TIM_OC3Init
    307              
    308              TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
   \   00000048   0x4669             MOV      R1,SP
   \   0000004A   0x....             LDR.N    R0,??DataTable17_15  ;; 0x40000800
   \   0000004C   0x.... 0x....      BL       TIM_TimeBaseInit
    309              TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Disable);
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x....             LDR.N    R0,??DataTable17_15  ;; 0x40000800
   \   00000054   0x.... 0x....      BL       TIM_OC3PreloadConfig
    310              TIM_ARRPreloadConfig(TIM4, ENABLE);
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x....             LDR.N    R0,??DataTable17_15  ;; 0x40000800
   \   0000005C   0x.... 0x....      BL       TIM_ARRPreloadConfig
    311              TIM_Cmd(TIM4, ENABLE);
   \   00000060   0x2101             MOVS     R1,#+1
   \   00000062   0x....             LDR.N    R0,??DataTable17_15  ;; 0x40000800
   \   00000064   0x.... 0x....      BL       TIM_Cmd
    312          }
   \   00000068   0xB007             ADD      SP,SP,#+28
   \   0000006A   0xBD00             POP      {PC}             ;; return
    313          
    314          // @@ @@ @@ (PWM @@)

   \                                 In section .text, align 2, keep-with-next
    315          void moveMotor(uint16_t var)
    316          {
   \                     moveMotor: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    317              TIM_OCInitTypeDef TIM_OCInitStructure;
    318              TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
   \   00000002   0x2160             MOVS     R1,#+96
   \   00000004   0xF8AD 0x1000      STRH     R1,[SP, #+0]
    319              TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF8AD 0x1008      STRH     R1,[SP, #+8]
    320              TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF8AD 0x1002      STRH     R1,[SP, #+2]
    321              TIM_OCInitStructure.TIM_Pulse = var;
   \   00000014   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    322              TIM_OC3Init(TIM4, &TIM_OCInitStructure);
   \   00000018   0x4669             MOV      R1,SP
   \   0000001A   0x....             LDR.N    R0,??DataTable17_15  ;; 0x40000800
   \   0000001C   0x.... 0x....      BL       TIM_OC3Init
    323          }
   \   00000020   0xB005             ADD      SP,SP,#+20
   \   00000022   0xBD00             POP      {PC}             ;; return
    324          
    325          // @@@@ @@@ @ @@ @@

   \                                 In section .text, align 2, keep-with-next
    326          int isOpen(void) {
    327              if(~GPIOD->IDR & GPIO_Pin_12) {
   \                     isOpen: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable17_16  ;; 0x40011408
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x43C0             MVNS     R0,R0
   \   00000006   0x04C0             LSLS     R0,R0,#+19
   \   00000008   0xD501             BPL.N    ??isOpen_0
    328                  return 0; // @@ @@@@ @@
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE000             B.N      ??isOpen_1
    329              }
    330              else {
    331                  return 1; // @@ @@ @@@ @@
   \                     ??isOpen_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \                     ??isOpen_1: (+1)
   \   00000010   0x4770             BX       LR               ;; return
    332              }
    333          }
    334          
    335          // @@@ @@@ @@ @@

   \                                 In section .text, align 2, keep-with-next
    336          int detectPerson(void) {
   \                     detectPerson: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    337            if(isOpen() == 1) { // @@ @@ @@ @@ @@ (@, @@@@ @@ @@@ @@@ @@)
   \   00000002   0x.... 0x....      BL       isOpen
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD116             BNE.N    ??detectPerson_0
    338                int distanceThr = 150;  // @@ @@ @@@
   \   0000000A   0x2496             MOVS     R4,#+150
    339                dist = HCSR04GetDistance(); // @@@ @@@ @@ @@ @@
   \   0000000C   0x.... 0x....      BL       HCSR04GetDistance
   \   00000010   0x.... 0x....      BL       __aeabi_i2d
   \   00000014   0x....             LDR.N    R2,??DataTable17_17
   \   00000016   0xE9C2 0x0100      STRD     R0,R1,[R2, #+0]
    340                if(distanceThr > dist) {
   \   0000001A   0x0020             MOVS     R0,R4
   \   0000001C   0x.... 0x....      BL       __aeabi_i2d
   \   00000020   0x0002             MOVS     R2,R0
   \   00000022   0x000B             MOVS     R3,R1
   \   00000024   0x....             LDR.N    R4,??DataTable17_17
   \   00000026   0xE9D4 0x0100      LDRD     R0,R1,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       __aeabi_cdcmple
   \   0000002E   0xD201             BCS.N    ??detectPerson_1
    341                    return 1;  // @@ @@@
   \   00000030   0x2001             MOVS     R0,#+1
   \   00000032   0xE001             B.N      ??detectPerson_2
    342                }
    343                else {
    344                    return 0;  // @@ @@
   \                     ??detectPerson_1: (+1)
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0xE7FF             B.N      ??detectPerson_2
    345                }
    346              }
    347          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "detectPerson"
   \                     ??detectPerson_0: (+1)
   \                     ??detectPerson_2: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
    348          
    349          // @ @@ @@

   \                                 In section .text, align 2, keep-with-next
    350          void open() {//@ @@ @@
   \                     open: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    351              if (isOpen() == 0) { //@@ @@ @@ @@ @@ @@
   \   00000002   0x.... 0x....      BL       isOpen
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD109             BNE.N    ??open_0
    352                  moveMotor(1000);  // @@ @@
   \   0000000A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000000E   0x.... 0x....      BL       moveMotor
    353                  for(int i=0; i < 26000000; i++) {}  // @@@@ @@@@@ @@
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xE000             B.N      ??open_1
   \                     ??open_2: (+1)
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \                     ??open_1: (+1)
   \   00000018   0x....             LDR.N    R1,??DataTable17_18  ;; 0x18cba80
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xDBFB             BLT.N    ??open_2
    354              }
    355              moveMotor(1500); //@@ @@
   \                     ??open_0: (+1)
   \   0000001E   0xF240 0x50DC      MOVW     R0,#+1500
   \   00000022   0x.... 0x....      BL       moveMotor
    356          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
    357          

   \                                 In section .text, align 2, keep-with-next
    358          void close() {
   \                     close: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    359              if (isOpen() == 1 && !detectPerson()) { // @@ @@ @@(detectPerson()@@ @@) @@@ @@ @@ @@ @@
   \   00000002   0x.... 0x....      BL       isOpen
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD10D             BNE.N    ??close_0
   \   0000000A   0x.... 0x....      BL       detectPerson
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD109             BNE.N    ??close_0
    360                  moveMotor(2000);  // @@ @@
   \   00000012   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000016   0x.... 0x....      BL       moveMotor
    361                  for(int i=0; i < 23000000; i++) {}  // @@@@ @@@@@ @@
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??close_1
   \                     ??close_2: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \                     ??close_1: (+1)
   \   00000020   0x....             LDR.N    R1,??DataTable17_19  ;; 0x15ef3c0
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xDBFB             BLT.N    ??close_2
    362              }
    363              //@@ off
    364              moveMotor(1500);
   \                     ??close_0: (+1)
   \   00000026   0xF240 0x50DC      MOVW     R0,#+1500
   \   0000002A   0x.... 0x....      BL       moveMotor
    365           }
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
    366          

   \                                 In section .text, align 2, keep-with-next
    367          void setRGBLED(int flag) {
    368              switch (flag) {
   \                     setRGBLED: (+1)
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD004             BEQ.N    ??setRGBLED_0
   \   00000004   0xD33C             BCC.N    ??setRGBLED_1
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD027             BEQ.N    ??setRGBLED_2
   \   0000000A   0xD313             BCC.N    ??setRGBLED_3
   \   0000000C   0xE038             B.N      ??setRGBLED_1
    369              case 1: // @@@
    370                  GPIOD->ODR |= (GPIO_Pin_2);  // @@@ @
   \                     ??setRGBLED_0: (+1)
   \   0000000E   0x....             LDR.N    R0,??DataTable17_20  ;; 0x4001140c
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000016   0x....             LDR.N    R1,??DataTable17_20  ;; 0x4001140c
   \   00000018   0x6008             STR      R0,[R1, #+0]
    371                  GPIOB->ODR &= ~(GPIO_Pin_2);   // @@@ @
   \   0000001A   0x....             LDR.N    R0,??DataTable17_21  ;; 0x40010c0c
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000022   0x....             LDR.N    R1,??DataTable17_21  ;; 0x40010c0c
   \   00000024   0x6008             STR      R0,[R1, #+0]
    372                  GPIOC->ODR |= (GPIO_Pin_5);  // @@@ @
   \   00000026   0x....             LDR.N    R0,??DataTable17_22  ;; 0x4001100c
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000002E   0x....             LDR.N    R1,??DataTable17_22  ;; 0x4001100c
   \   00000030   0x6008             STR      R0,[R1, #+0]
    373                  break;
   \   00000032   0xE037             B.N      ??setRGBLED_4
    374              case 2: // @@@ (@@ + @@)
    375                  GPIOD->ODR &= ~(GPIO_Pin_2);  // @@@ @
   \                     ??setRGBLED_3: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable17_20  ;; 0x4001140c
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000003C   0x....             LDR.N    R1,??DataTable17_20  ;; 0x4001140c
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    376                  GPIOB->ODR &= ~(GPIO_Pin_2);  // @@@ @
   \   00000040   0x....             LDR.N    R0,??DataTable17_21  ;; 0x40010c0c
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000048   0x....             LDR.N    R1,??DataTable17_21  ;; 0x40010c0c
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    377                  GPIOC->ODR |= (GPIO_Pin_5);  // @@@ @
   \   0000004C   0x....             LDR.N    R0,??DataTable17_22  ;; 0x4001100c
   \   0000004E   0x6800             LDR      R0,[R0, #+0]
   \   00000050   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   00000054   0x....             LDR.N    R1,??DataTable17_22  ;; 0x4001100c
   \   00000056   0x6008             STR      R0,[R1, #+0]
    378                  break;
   \   00000058   0xE024             B.N      ??setRGBLED_4
    379              case 3: // @@@
    380                  GPIOD->ODR &= ~(GPIO_Pin_2);  // @@@ @
   \                     ??setRGBLED_2: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable17_20  ;; 0x4001140c
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0xF030 0x0004      BICS     R0,R0,#0x4
   \   00000062   0x....             LDR.N    R1,??DataTable17_20  ;; 0x4001140c
   \   00000064   0x6008             STR      R0,[R1, #+0]
    381                  GPIOB->ODR |= (GPIO_Pin_2);  // @@@ @
   \   00000066   0x....             LDR.N    R0,??DataTable17_21  ;; 0x40010c0c
   \   00000068   0x6800             LDR      R0,[R0, #+0]
   \   0000006A   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000006E   0x....             LDR.N    R1,??DataTable17_21  ;; 0x40010c0c
   \   00000070   0x6008             STR      R0,[R1, #+0]
    382                  GPIOC->ODR |= (GPIO_Pin_5);  // @@@ @
   \   00000072   0x....             LDR.N    R0,??DataTable17_22  ;; 0x4001100c
   \   00000074   0x6800             LDR      R0,[R0, #+0]
   \   00000076   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   0000007A   0x....             LDR.N    R1,??DataTable17_22  ;; 0x4001100c
   \   0000007C   0x6008             STR      R0,[R1, #+0]
    383                  break;
   \   0000007E   0xE011             B.N      ??setRGBLED_4
    384              default: // @@@ (@@, @@, @@@ @@ @)
    385                GPIOD->ODR |= GPIO_Pin_2;
   \                     ??setRGBLED_1: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable17_20  ;; 0x4001140c
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000088   0x....             LDR.N    R1,??DataTable17_20  ;; 0x4001140c
   \   0000008A   0x6008             STR      R0,[R1, #+0]
    386                  GPIOB->ODR |= GPIO_Pin_2;
   \   0000008C   0x....             LDR.N    R0,??DataTable17_21  ;; 0x40010c0c
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   00000094   0x....             LDR.N    R1,??DataTable17_21  ;; 0x40010c0c
   \   00000096   0x6008             STR      R0,[R1, #+0]
    387                  GPIOC->ODR |= GPIO_Pin_5;
   \   00000098   0x....             LDR.N    R0,??DataTable17_22  ;; 0x4001100c
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0xF050 0x0020      ORRS     R0,R0,#0x20
   \   000000A0   0x....             LDR.N    R1,??DataTable17_22  ;; 0x4001100c
   \   000000A2   0x6008             STR      R0,[R1, #+0]
    388                  break;
    389          }
    390          }
   \                     ??setRGBLED_4: (+1)
   \   000000A4   0x4770             BX       LR               ;; return
    391          
    392          

   \                                 In section .bss, align 2
    393          volatile uint16_t pressure_value = 0;
   \                     pressure_value:
   \   00000000                      DS8 2
    394          

   \                                 In section .text, align 2, keep-with-next
    395          int main(void) {
   \                     main: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    396              SystemInit();
   \   00000002   0x.... 0x....      BL       SystemInit
    397              RCC_Configure();
   \   00000006   0x.... 0x....      BL       RCC_Configure
    398              GPIO_Configure();
   \   0000000A   0x.... 0x....      BL       GPIO_Configure
    399              ADC_Configure();
   \   0000000E   0x.... 0x....      BL       ADC_Configure
    400              NVIC_Configure();
   \   00000012   0x.... 0x....      BL       NVIC_Configure
    401              USART1_Init();
   \   00000016   0x.... 0x....      BL       USART1_Init
    402              USART2_Init();
   \   0000001A   0x.... 0x....      BL       USART2_Init
    403              InitHCSR04();
   \   0000001E   0x.... 0x....      BL       InitHCSR04
    404              TIM4_Configure();
   \   00000022   0x.... 0x....      BL       TIM4_Configure
    405          
    406              setRGBLED(flag);
   \   00000026   0x....             LDR.N    R0,??DataTable17_23
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x.... 0x....      BL       setRGBLED
   \   0000002E   0xE013             B.N      ??main_0
    407              
    408              while (1) {
    409                  if (flagUART1 == 1){
    410                      sendDataUART2(wordFromUART1);
    411                      flagUART1 = 0;
    412                  }
    413                  else if (flagUART2 == 1){
    414                      sendDataUART1(wordFromUART2);
    415                      flagUART2 = 0;
    416          
    417                      // 'o'@ @@@ @ @@
    418                      if(wordFromUART2 == 'o') {
    419                          open();
    420                      }
    421                      // 'c'@ @@@ @ @@
    422                      else if(wordFromUART2 == 'c') {
    423                          close();
    424                      }
    425                      else if(wordFromUART2 == 's') {
    426                          moveMotor(1500);
    427                      }
    428          
    429                  }
    430                  
    431                  // @@ @@@@ @@ @@ @@
    432                  if(pressureValue < pressureThreshold1) {
    433                      flag = 1;
    434                  }
    435                  else if(pressureValue < pressureThreshold2) {
    436                      flag = 2;
    437                  }
    438                  else {
    439                      flag = 3;
   \                     ??main_1: (+1)
   \   00000030   0x2003             MOVS     R0,#+3
   \   00000032   0x....             LDR.N    R1,??DataTable17_23
   \   00000034   0x6008             STR      R0,[R1, #+0]
   \   00000036   0xE00B             B.N      ??main_2
    440                  }
   \                     ??main_3: (+1)
   \   00000038   0x....             LDR.N    R2,??DataTable17_12
   \   0000003A   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   0000003E   0x....             LDR.N    R4,??DataTable17_24
   \   00000040   0xE9D4 0x2300      LDRD     R2,R3,[R4, #+0]
   \   00000044   0x.... 0x....      BL       __aeabi_cdcmple
   \   00000048   0xD2F2             BCS.N    ??main_1
   \   0000004A   0x2002             MOVS     R0,#+2
   \   0000004C   0x....             LDR.N    R1,??DataTable17_23
   \   0000004E   0x6008             STR      R0,[R1, #+0]
    441                  
    442                  setRGBLED(flag);
   \                     ??main_2: (+1)
   \   00000050   0x....             LDR.N    R0,??DataTable17_23
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x.... 0x....      BL       setRGBLED
   \                     ??main_0: (+1)
   \   00000058   0x....             LDR.N    R0,??DataTable17_7
   \   0000005A   0x7800             LDRB     R0,[R0, #+0]
   \   0000005C   0x2801             CMP      R0,#+1
   \   0000005E   0xD108             BNE.N    ??main_4
   \   00000060   0x....             LDR.N    R0,??DataTable17_8
   \   00000062   0x7800             LDRB     R0,[R0, #+0]
   \   00000064   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000066   0x.... 0x....      BL       sendDataUART2
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x....             LDR.N    R1,??DataTable17_7
   \   0000006E   0x7008             STRB     R0,[R1, #+0]
   \   00000070   0xE021             B.N      ??main_5
   \                     ??main_4: (+1)
   \   00000072   0x....             LDR.N    R0,??DataTable17_9
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x2801             CMP      R0,#+1
   \   00000078   0xD11D             BNE.N    ??main_5
   \   0000007A   0x....             LDR.N    R0,??DataTable17_10
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000080   0x.... 0x....      BL       sendDataUART1
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x....             LDR.N    R1,??DataTable17_9
   \   00000088   0x7008             STRB     R0,[R1, #+0]
   \   0000008A   0x....             LDR.N    R0,??DataTable17_10
   \   0000008C   0x7800             LDRB     R0,[R0, #+0]
   \   0000008E   0x286F             CMP      R0,#+111
   \   00000090   0xD102             BNE.N    ??main_6
   \   00000092   0x.... 0x....      BL       open
   \   00000096   0xE00E             B.N      ??main_5
   \                     ??main_6: (+1)
   \   00000098   0x....             LDR.N    R0,??DataTable17_10
   \   0000009A   0x7800             LDRB     R0,[R0, #+0]
   \   0000009C   0x2863             CMP      R0,#+99
   \   0000009E   0xD102             BNE.N    ??main_7
   \   000000A0   0x.... 0x....      BL       close
   \   000000A4   0xE007             B.N      ??main_5
   \                     ??main_7: (+1)
   \   000000A6   0x....             LDR.N    R0,??DataTable17_10
   \   000000A8   0x7800             LDRB     R0,[R0, #+0]
   \   000000AA   0x2873             CMP      R0,#+115
   \   000000AC   0xD103             BNE.N    ??main_5
   \   000000AE   0xF240 0x50DC      MOVW     R0,#+1500
   \   000000B2   0x.... 0x....      BL       moveMotor
   \                     ??main_5: (+1)
   \   000000B6   0x....             LDR.N    R2,??DataTable17_12
   \   000000B8   0xE9D2 0x0100      LDRD     R0,R1,[R2, #+0]
   \   000000BC   0x....             LDR.N    R4,??DataTable17_25
   \   000000BE   0xE9D4 0x2300      LDRD     R2,R3,[R4, #+0]
   \   000000C2   0x.... 0x....      BL       __aeabi_cdcmple
   \   000000C6   0xD2B7             BCS.N    ??main_3
   \   000000C8   0x2001             MOVS     R0,#+1
   \   000000CA   0x....             LDR.N    R1,??DataTable17_23
   \   000000CC   0x6008             STR      R0,[R1, #+0]
   \   000000CE   0xE7BF             B.N      ??main_2
    443                  
    444              }
    445               return 0;
                      ^
Warning[Pe111]: statement is unreachable
    446          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x40011400         DC32     0x40011400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x40013800         DC32     0x40013800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x40004400         DC32     0x40004400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     flagUART1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     wordFromUART1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     flagUART2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     wordFromUART2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x40012400         DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     pressureValue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     SystemCoreClock

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x000F4240         DC32     0xf4240

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x40000800         DC32     0x40000800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x40011408         DC32     0x40011408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x........         DC32     dist

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x018CBA80         DC32     0x18cba80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0x015EF3C0         DC32     0x15ef3c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0x4001140C         DC32     0x4001140c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x40010C0C         DC32     0x40010c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \   00000000   0x4001100C         DC32     0x4001100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \   00000000   0x........         DC32     flag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \   00000000   0x........         DC32     pressureThreshold2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \   00000000   0x........         DC32     pressureThreshold1

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ADC1_2_IRQHandler
         8   -> ADC_ClearITPendingBit
         8   -> ADC_GetConversionValue
         8   -> ADC_GetITStatus
         8   -> __aeabi_ui2d
      24   ADC_Configure
        24   -> ADC_Cmd
        24   -> ADC_DeInit
        24   -> ADC_GetCalibrationStatus
        24   -> ADC_GetResetCalibrationStatus
        24   -> ADC_ITConfig
        24   -> ADC_Init
        24   -> ADC_RegularChannelConfig
        24   -> ADC_ResetCalibration
        24   -> ADC_SoftwareStartConvCmd
        24   -> ADC_StartCalibration
       8   GPIO_Configure
         8   -> GPIO_Init
       8   NVIC_Configure
         8   -> NVIC_Init
         8   -> NVIC_PriorityGroupConfig
         8   -> __NVIC_EnableIRQ
       8   RCC_Configure
         8   -> RCC_APB1PeriphClockCmd
         8   -> RCC_APB2PeriphClockCmd
      32   TIM4_Configure
        32   -> TIM_ARRPreloadConfig
        32   -> TIM_Cmd
        32   -> TIM_OC3Init
        32   -> TIM_OC3PreloadConfig
        32   -> TIM_TimeBaseInit
       8   USART1_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
      24   USART1_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       8   USART2_IRQHandler
         8   -> USART_ClearITPendingBit
         8   -> USART_GetITStatus
         8   -> USART_ReceiveData
      24   USART2_Init
        24   -> USART_Cmd
        24   -> USART_ITConfig
        24   -> USART_Init
       0   __NVIC_EnableIRQ
       8   close
         8   -> detectPerson
         8   -> isOpen
         8   -> moveMotor
       8   detectPerson
         8   -> HCSR04GetDistance
         8   -> __aeabi_i2d
         8   -> isOpen
         8 __aeabi_cdcmple
       0   isOpen
       8   main
         8   -> ADC_Configure
         8   -> GPIO_Configure
         8   -> InitHCSR04
         8   -> NVIC_Configure
         8   -> RCC_Configure
         8   -> SystemInit
         8   -> TIM4_Configure
         8   -> USART1_Init
         8   -> USART2_Init
         8   -> close
         8   -> moveMotor
         8   -> open
         8   -> sendDataUART1
         8   -> sendDataUART2
         8   -> setRGBLED
         8 __aeabi_cdcmple
      24   moveMotor
        24   -> TIM_OC3Init
       8   open
         8   -> isOpen
         8   -> moveMotor
       8   sendDataUART1
         8   -> USART_SendData
       8   sendDataUART2
         8   -> USART_SendData
       0   setRGBLED


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      44  ADC1_2_IRQHandler
     146  ADC_Configure
     280  GPIO_Configure
     138  NVIC_Configure
      92  RCC_Configure
     108  TIM4_Configure
      54  USART1_IRQHandler
      76  USART1_Init
      54  USART2_IRQHandler
      76  USART2_Init
      30  __NVIC_EnableIRQ
      48  close
      58  detectPerson
       8  dist
       4  flag
       1  flagUART1
       1  flagUART2
      18  isOpen
     208  main
      36  moveMotor
      40  open
       8  pressureThreshold1
       8  pressureThreshold2
       8  pressureValue
       2  pressure_value
      16  sendDataUART1
      16  sendDataUART2
     166  setRGBLED
       1  wordFromUART1
       1  wordFromUART2

 
    26 bytes in section .bss
    16 bytes in section .data
 1 808 bytes in section .text
 
 1 808 bytes of CODE memory
    42 bytes of DATA memory

Errors: none
Warnings: 2
